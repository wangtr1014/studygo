package main

import "fmt"

func main() {
	//make([]T, size, cap)
	a := make([]int, 2, 10)
	fmt.Println(a)      //[0 0]
	fmt.Println(len(a)) //2
	fmt.Println(cap(a)) //10
	//上面代码中a的内部存储空间已经分配了10个，但实际上只用了2个。
	//容量并不会影响当前元素的个数，所以len(a)返回2，cap(a)则返回该切片的容量。

	//切片的本质就是一个框，框住了一块连续的内存。
	//切片属于引用类型，真正的数据保存在底层数组里

	//nil还没有申请内存空间
	//切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。
	//切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。
	//但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例：
	//var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil
	//s2 := []int{}        //len(s2)=0;cap(s2)=0;s2!=nil
	//s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
	//所以要判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断。

	//切片的遍历和数组一致

	//切片的拷贝
	s1 := make([]int, 3) //[0 0 0]
	s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组
	s2[0] = 100
	fmt.Println(s1) //[100 0 0]
	fmt.Println(s2) //[100 0 0]
}
